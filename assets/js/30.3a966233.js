(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{500:function(t,e,v){"use strict";v.r(e);var _=v(12),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"关于多线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于多线程"}},[t._v("#")]),t._v(" 关于多线程")]),t._v(" "),v("h2",{attrs:{id:"概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[t._v("#")]),t._v(" 概念")]),t._v(" "),v("blockquote",[v("p",[t._v("线程的 POSIX 标准。该标准定义了创建和操纵线程的一整套 API。在类 Unix 操作系统（Unix、Linux、Mac OS X 等）中，都使用 Pthreads 作为操作系统的线程。")])]),t._v(" "),v("h2",{attrs:{id:"问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[t._v("#")]),t._v(" 问题")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("进程和线程的区别？")])])]),t._v(" "),v("p",[t._v("进程：表示一个正在执行的程序的一个实例，并用"),v("code",[t._v("ProcessID")]),t._v("来进行标识")]),t._v(" "),v("p",[t._v("线程：表示一组寄存器的状态，现在操作系统，都把线程作为基本执行单元。")]),t._v(" "),v("p",[t._v("**关系：**一个进程中可以存在多个线程，一个进程内的所有线程都共享虚拟内存空间")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("多线程的优点：")]),t._v(" "),v("strong",[t._v("你理解的多线程")])])]),t._v(" "),v("p",[t._v("一个线程的状态可以独立于其他线程。因此，当一个线程在睡眠时，另一个线程可以被调度到 CPU 上执行。通过这种操作就可以实现并发操作。")]),t._v(" "),v("p",[t._v("线程之间切换的开销比较小--只需要保存和恢复寄存器即可。进程切换除此之外还需要切换虚拟内存空间")]),t._v(" "),v("p",[t._v("实现并发和异步操作")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("线程之间如何进行通讯")])])]),t._v(" "),v("p",[t._v("表现形式：就是一个线程将当前数据转移到指定线程中去。\n实现方式：NSTread、pthread、GCD、NSOperation")]),t._v(" "),v("p",[t._v("性能:GCD 更接近底层，而 NSOperationQueue 则更高级抽象，所以 GCD 在追求性能的底层操作来说，是速度最快的。这取决于使用 Instruments 进行代码性能分析，如有必要的话")]),t._v(" "),v("p",[t._v("从异步操作之间的事务性，顺序行，依赖关系。GCD 需要自己写更多的代码来实现，而 NSOperationQueue 已经内建了这些支持")]),t._v(" "),v("p",[t._v("如果异步操作的过程需要更多的被交互和 UI 呈现出来，NSOperationQueue 会是一个更好的选择。底层代码中，任务之间不太互相依赖，而需要更高的并发能力，GCD 则更有优势")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("同步和异步有什么区别？")])])]),t._v(" "),v("p",[t._v("同步：一个线程要等待上一个线程执行完之后才能执行当前的线程\n异步：同时去做两件或者多件事。比如后台线程来执行耗时下载")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("串行队列和并发队列有什么区别？")])])]),t._v(" "),v("p",[t._v("队列（queue）：是先进先出（FIFO, First-In-First-Out）的线性表")]),t._v(" "),v("p",[t._v("串行队列：队列中的任务要串行执行，也就是一个一个的执行，必须等上一个任务执行完成之后才能开始下一个，而且一定是按照先进先出的顺序执行的")]),t._v(" "),v("p",[t._v("并发队列：队列中的任务可以并发执行，也就任务可以同时执行")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("队列和线程的关系")])])]),t._v(" "),v("p",[t._v("关于同步异步、串行并行和线程的关系，下面通过一个表格来总结")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th"),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("同步")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("异步")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("主队列")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("在主线程中执行")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("在主线程中执行")])]),t._v(" "),v("tr",[v("td",[t._v("串行队列")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("在当前线程中执行")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("新建线程执行")])]),t._v(" "),v("tr",[v("td",[t._v("并发队列")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("在当前线程中执行")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("新建线程执行")])])])]),t._v(" "),v("p",[t._v("可以看到，同步方法不一定在本线程，异步方法方法也不一定新开线程（考虑主队列）。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("不使用 gcd，如何保证线程安全？")])])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("为什么要在主线程更新 UI")])])]),t._v(" "),v("p",[t._v("UIKit 中，UIView 并不是一个线程安全的类。")]),t._v(" "),v("p",[t._v("另一方面因为整个程序的起点 UIApplication 是在主线程进行初始化，所有的用户事件都是在主线程上进行传递（如点击、拖动），所以 view 只能在主线程上才能对事件进行响应。")]),t._v(" "),v("blockquote",[v("p",[t._v("把 UIKit 设计成线程安全并不会带来太多的便利，也不会提升太多的性能表现，甚至会因为加锁解锁而耗费大量的时间。事实上并发编程也没有因为 UIKit 是线程不安全而变得困难，我们所需要做的只是要确保 UI 操作在主线程进行就可以了。")])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("如何把异步线程转换成同步任务进行单元测试")])])]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("iOS 中实现多线程的几种方案，各自有什么特点？讲一下具体使用场景/在项目什么时候选择使用 GCD，什么时候选 择 NSOperation? 你更倾向于哪一种？")])])]),t._v(" "),v("p",[t._v("（NSOperation、NSThread、GCD）")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("1. 图片下载任务操作中使用GCD\n2. 文件读写\n")])])]),v("ul",[v("li",[v("strong",[t._v("讲一下 atomic 的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？")])])]),t._v(" "),v("p",[t._v("在 UIKit 中，很多类中大部分的属性都被修饰为 nonatomic，这意味着它们不能在多线程的环境下工作，而对于 UIKit 这样一个庞大的框架，将其所有属性都设计为线程安全是不现实的，这可不仅仅是简单的将 nonatomic 改成 atomic 或者是加锁解锁的操作，还涉及到很多的方面：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[t._v("* 假设能够异步设置view的属性，那我们究竟是希望这些改动能够同时生效，还是按照各自runloop的进度去改变这个view的属性呢？\n* 假设UITableView在其他线程去移除了一个cell，而在另一个线程却对这个cell所在的index进行一些操作，这时候可能就会引发crash。\n* 如果在后台线程移除了一个view，这个时候runloop周期还没有完结，用户在主线程点击了这个“将要”消失的view，那么究竟该不该响应事件？在哪条线程进行响应？\n")])])]),v("p",[t._v("仔细思考，似乎能够多线程处理 UI 并没有给我们开发带来更多的便利，假如你代入了这些情景进行思考，你很容易得出一个结论： “我在一个串行队列对这些事件进行处理就可以了。” 苹果也是这样想的，所以 UIKit 的所有操作都要放到主线程串行执行。")]),t._v(" "),v("ul",[v("li",[v("p",[v("strong",[t._v("怎么实现多个任务执行完后，再统一处理")])])]),t._v(" "),v("li",[v("p",[t._v("给了我一个例子，让说这样非 ARC 情况写在多线程下会有什么问题，改为 ARC 呢，改为手动加 autoreleasepool 呢（其实也是考虑内存管理和释放，会不会导致野指针的不正常使用）")])])]),t._v(" "),v("h2",{attrs:{id:"锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),v("ul",[v("li",[t._v("锁有哪些？\nOSSpinLock、pthread_mutex、NSLock")]),t._v(" "),v("li",[t._v("线程死锁的四个条件")]),t._v(" "),v("li",[t._v("多线程的死锁问题")]),t._v(" "),v("li",[t._v("线程安全错误是怎么出现的？")])]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/ThreadSafetySummary/ThreadSafetySummary.html#//apple_ref/doc/uid/10000057i-CH12-SW1",target:"_blank",rel:"noopener noreferrer"}},[t._v("苹果多线程编程指南"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://bestswifter.com/multithreadconclusion/",target:"_blank",rel:"noopener noreferrer"}},[t._v("iOS 多线程编程总结"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=a.exports}}]);