(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{477:function(t,a,e){"use strict";e.r(a);var s=e(12),l=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"协议"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协议"}},[t._v("#")]),t._v(" 协议")]),t._v(" "),e("p",[t._v("在 Swift 里，一个协议表示一组正式提出的要求 (requirements)。例如，Equatable 协议要求 实现的类型提供 == 操作符。")]),t._v(" "),e("h2",{attrs:{id:"主要特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#主要特性"}},[t._v("#")]),t._v(" 主要特性")]),t._v(" "),e("ul",[e("li",[t._v("协议可以自行扩展新的功能")])]),t._v(" "),e("p",[t._v("最简单的例子就是 Equatable，它要求实现的类型提供 == 操作 符。")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("协议可以通过条件化扩展 (conditional extensions) 添加需要额外约束的 API")]),t._v(" "),e("p",[t._v("例如，在 Collection 协议中，只有 Element 实现了 Comparable 的时候，才提供了 max() 方法")])]),t._v(" "),e("li",[e("p",[t._v("协议可以继承其它协议")])])]),t._v(" "),e("p",[t._v("例如，Hashable 要求实现的类型必须同时实现 Equatable 协议。")]),t._v(" "),e("ul",[e("li",[t._v("协议还可以被组合起来形成新的协议")])]),t._v(" "),e("p",[t._v("标准库中的 Codable 就是 Encodable 和 Decodable 协议组合之后的别名。")]),t._v(" "),e("ul",[e("li",[t._v("协议还可以声明关联类型，实现了这个协议的类型就需要定义关联类型对应的具体类型")])]),t._v(" "),e("blockquote",[e("p",[t._v("每一个协议都会引入一层额外的抽象， 有时，这会增加理解代码的难度。但有时，使用协议又可以极大地简化代码。这需要不断在编 码中积累经验，才能 (在复杂度和表意上) 找到平衡。")])]),t._v(" "),e("h2",{attrs:{id:"协议和关联类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协议和关联类型"}},[t._v("#")]),t._v(" 协议和关联类型")]),t._v(" "),e("p",[t._v("有些协议需要约束的不仅仅是方法、属性和初始化方法，它们还希望和它相关的一些类型满足 特定的条件。这就可以通过关联类型 (associated type) 来实现。")]),t._v(" "),e("h2",{attrs:{id:"类型消除器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型消除器"}},[t._v("#")]),t._v(" 类型消除器")]),t._v(" "),e("p",[t._v("尽管我们无法为带有 Self 或关联类型约束的协议创建存在体，但我们可以编写一个执行类似功 能的函数，叫做：类型消除器 (type erasers)。")])])}),[],!1,null,null,null);a.default=l.exports}}]);