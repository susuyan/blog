(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{509:function(l,t,_){"use strict";_.r(t);var o=_(12),v=Object(o.a)({},(function(){var l=this,t=l.$createElement,_=l._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[_("h1",{attrs:{id:"关于-block"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于-block"}},[l._v("#")]),l._v(" 关于 Block")]),l._v(" "),_("h2",{attrs:{id:"block-的循环引用、如何解决、原理？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block-的循环引用、如何解决、原理？"}},[l._v("#")]),l._v(" - "),_("strong",[l._v("Block 的循环引用、如何解决、原理？")])]),l._v(" "),_("p",[l._v("使用 weak，__block,关键字来修饰对象。")]),l._v(" "),_("h2",{attrs:{id:"block-和-delegate-的比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block-和-delegate-的比较"}},[l._v("#")]),l._v(" - "),_("strong",[l._v("Block 和 delegate 的比较")])]),l._v(" "),_("ul",[_("li",[l._v("都可做回调来使用。")]),l._v(" "),_("li",[l._v("block，会有循环引用风险，所以要进行代码管理")]),l._v(" "),_("li",[l._v("delegate 没有延长某个对象生命周期，代码更加清晰，易于管理")]),l._v(" "),_("li",[l._v("block 适合做集约型调用")]),l._v(" "),_("li",[l._v("delegate 适合做离散型调用")])]),l._v(" "),_("p",[l._v("总之，要灵活的使用 block 和 delegate。")]),l._v(" "),_("h2",{attrs:{id:"block-本质是什么？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block-本质是什么？"}},[l._v("#")]),l._v(" - "),_("strong",[l._v("block 本质是什么？")])]),l._v(" "),_("p",[l._v("简单理解，匿名函数，然后将匿名函数当做对象来看")]),l._v(" "),_("h2",{attrs:{id:"block-和函数指针的理解？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block-和函数指针的理解？"}},[l._v("#")]),l._v(" - "),_("strong",[l._v("block 和函数指针的理解？")])]),l._v(" "),_("p",[l._v("相似点：函数指针和 block 都可以实现回调的操作，声明上也相似")]),l._v(" "),_("p",[l._v("不同点：\n_ 函数指针只能指向预先定义好的函数代码块，函数地址是在编译链接时就已经确定好的。\n_ block 的本质即使一个对象，可以接受消息\n_ 函数指针只能访问全局变量，而 block 不光能访问全局变量，还拥有当前栈内存和堆内存变量\n_ 从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而 block 实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送 copy 消息将 block 对象拷贝到堆内存，以延长其生命周期。")]),l._v(" "),_("h2",{attrs:{id:"block-为什么会有循环引用？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#block-为什么会有循环引用？"}},[l._v("#")]),l._v(" - "),_("strong",[l._v("block 为什么会有循环引用？")])]),l._v(" "),_("p",[l._v("在 block 块中捕获变量，导致变量不能释放，所以造成循环引用")]),l._v(" "),_("ul",[_("li",[_("strong",[l._v("一个 int 变量被__block 修饰与否的区别？")])])]),l._v(" "),_("p",[l._v("没有修饰，被 block 捕获，是值拷贝。使用修饰时，会生成一个结构体，复制 int 的引用地址，达到修改数据。")]),l._v(" "),_("ul",[_("li",[_("p",[l._v("为什么在 block 外部使用"),_("strong",[l._v("weak 修饰的同时需要在内部使用")]),l._v("strong 修饰？")])]),l._v(" "),_("li",[_("p",[l._v("Block 的变量截获的")])]),l._v(" "),_("li",[_("p",[l._v("__block 的实现原理")])]),l._v(" "),_("li",[_("p",[l._v("Block 的变量截获机制（局部变量：基础类型，对象类型，静态变量；全局变量：静态，非静态 blahblah）")])]),l._v(" "),_("li",[_("p",[l._v("说说你对 block 的理解。—— 三种 block，栈上的自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。")])])])])}),[],!1,null,null,null);t.default=v.exports}}]);