(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{492:function(t,e,i){"use strict";i.r(e);var l=i(12),n=Object(l.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h1",{attrs:{id:"runtime"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[t._v("#")]),t._v(" Runtime")]),t._v(" "),i("ul",[i("li",[i("strong",[t._v("runtime 中，SEL 和 IMP 的区别")])])]),t._v(" "),i("p",[t._v("SEL：类成员方法的指针，方法编号\nIMP：函数指针，保存了方法地址")]),t._v(" "),i("p",[t._v("SEL(方法编号)最终会通过 Dispatch table 表寻找到对应的 IMP(函数指针)\nDispatch table 表存放 SEL 和 IMP 的对应")]),t._v(" "),i("ul",[i("li",[i("strong",[t._v("runtime 如何通过 selector 找到对应的 IMP 地址")])])]),t._v(" "),i("ul",[i("li",[i("p",[t._v("runtime 动态创建一个类，需要注意什么？")])]),t._v(" "),i("li",[i("p",[t._v("Runtime 实现的机制是什么？能做什么事情呢？")])]),t._v(" "),i("li",[i("p",[t._v("在运行时创建类的方法 objc_allocateClassPair 的方法名尾部为什么是 pair（成对的意思）？")])]),t._v(" "),i("li",[i("p",[t._v("App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少）")])]),t._v(" "),i("li",[i("p",[t._v("说说你对 runtime 的理解。——主要是方法调用时如何查找缓存，如何找到方法，找不到方法时怎么转发，对象的内存布局。")])]),t._v(" "),i("li",[i("p",[t._v("runtime 中，SEL 和 IMP 的区别")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);