(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{466:function(v,_,a){"use strict";a.r(_);var i=a(12),l=Object(i.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#算法"}},[v._v("#")]),v._v(" 算法")]),v._v(" "),a("h2",{attrs:{id:"字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串"}},[v._v("#")]),v._v(" 字符串")]),v._v(" "),a("ul",[a("li",[v._v("还有一个很长字符串，你用什么算法搜索到 abc 的位置？")]),v._v(" "),a("li",[v._v("字符串如何预处理？")]),v._v(" "),a("li",[v._v("查找字符串算法")]),v._v(" "),a("li",[v._v("字符串的全排列（简单的 dfs 题，注意下重复字符就行）")]),v._v(" "),a("li",[v._v("字符串最长匹配")]),v._v(" "),a("li",[v._v("最长回文子串")]),v._v(" "),a("li",[v._v("最长无重复子串")]),v._v(" "),a("li",[v._v("KMP 算法")]),v._v(" "),a("li",[v._v("字符串全排列")]),v._v(" "),a("li",[v._v("翻转字符串")])]),v._v(" "),a("h2",{attrs:{id:"动态规划"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态规划"}},[v._v("#")]),v._v(" 动态规划")]),v._v(" "),a("ul",[a("li",[v._v("背包问题")]),v._v(" "),a("li",[v._v("连续子数组的最大和")]),v._v(" "),a("li",[v._v("实现简单的正则表达式匹配")])]),v._v(" "),a("h2",{attrs:{id:"数组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[v._v("#")]),v._v(" 数组")]),v._v(" "),a("ul",[a("li",[v._v("如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？")]),v._v(" "),a("li",[v._v("写了个 \b 旋转数组找最小数字的题")]),v._v(" "),a("li",[v._v("数组匹配算法")]),v._v(" "),a("li",[v._v("两个数组，都没有重复值，都无序，求两个数组的交集")]),v._v(" "),a("li",[v._v("二维有序数组查找数字——剑指 offer 第 3 题")]),v._v(" "),a("li",[v._v("求数组中和为某个值的所有子数组，比如数组是[5,5,10,2,3]一共有四个子数组的和是 15，比如[5,10]，[5,10]，[10,2,3]，[5,5,2,3]。这个就是简单的递归了，分两种情况，当前位置的数字在子数组中，以及不在子数组中。")]),v._v(" "),a("li",[v._v("求两个等长、有序数组的中位数（二分法）")]),v._v(" "),a("li",[v._v("求两个不等长、有序数组的中位数")]),v._v(" "),a("li",[v._v("旋转数组求最小值、【3】旋转数组求查找某个值是否存在（二分法）")]),v._v(" "),a("li",[v._v("每行从左到右，每列从上到下递增的二维数组中，判断某个数是否存在（剑指 offer 第 3 题）")]),v._v(" "),a("li",[v._v("数组中出现次数超过一半的数字")]),v._v(" "),a("li",[v._v("第 k 大的数（拓展：最大的 k 个数）")]),v._v(" "),a("li",[v._v("有序数组中某个数字出现的次数（提示：利用二分搜索）")])]),v._v(" "),a("h2",{attrs:{id:"链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[v._v("#")]),v._v(" 链表")]),v._v(" "),a("ul",[a("li",[v._v("两个无限长度链表（也就是可能有环） 判断有没有交点")]),v._v(" "),a("li",[v._v("如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？")]),v._v(" "),a("li",[v._v("反转链表")]),v._v(" "),a("li",[v._v("合并排序链表")]),v._v(" "),a("li",[v._v("两个无限长度链表（也就是可能有环） 判断有没有交点")]),v._v(" "),a("li",[v._v("删除链表的当前节点")]),v._v(" "),a("li",[v._v("删除倒数第 k 个节点")]),v._v(" "),a("li",[v._v("两个有序链表合并")]),v._v(" "),a("li",[v._v("复杂链表的复制")]),v._v(" "),a("li",[v._v("判断链表是否有环")]),v._v(" "),a("li",[v._v("两个链表的第一个公共节点（提示：考虑链表有环的情况）")]),v._v(" "),a("li",[v._v("删除链表中重复节点")])]),v._v(" "),a("h2",{attrs:{id:"树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#树"}},[v._v("#")]),v._v(" 树")]),v._v(" "),a("ul",[a("li",[v._v("【3】根据中序和后序遍历结果重建二叉树、【3】根据中序和前序遍历结果重建二叉树")]),v._v(" "),a("li",[v._v("【2】翻转二叉树")]),v._v(" "),a("li",[v._v("【2】从上往下打印二叉树 (BFS 的思想)")]),v._v(" "),a("li",[v._v("【3】判断某个数组是不是二叉树的后序遍历结果 (剑指 offer 第 24 题)")]),v._v(" "),a("li",[v._v("【3】二叉树中和为某个值的路径")]),v._v(" "),a("li",[v._v("【3*】二叉树中某个节点的下一个节点 (强烈推荐准备一下，剑指 offer 第 58 题)")])]),v._v(" "),a("h2",{attrs:{id:"栈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[v._v("#")]),v._v(" 栈")]),v._v(" "),a("ul",[a("li",[v._v("【2】用两个栈实现队列、【2】用两个队列实现栈")]),v._v(" "),a("li",[v._v("【2】实现一个栈，可以用常数级时间找出栈中的最小值")]),v._v(" "),a("li",[v._v("【3】判断栈的压栈、弹栈序列是否合法（剑指 offer 第 22 题）")])]),v._v(" "),a("h2",{attrs:{id:"递归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#递归"}},[v._v("#")]),v._v(" 递归")]),v._v(" "),a("ul",[a("li",[v._v("如何不试用递归，打印所有一个 UIView 所有的 subviews（包括孙子 view 等）")])]),v._v(" "),a("h2",{attrs:{id:"排序："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#排序："}},[v._v("#")]),v._v(" 排序：")]),v._v(" "),a("ul",[a("li",[v._v("冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？")]),v._v(" "),a("li",[a("strong",[v._v("快排")]),v._v(" 原理，如何 \b 优化")]),v._v(" "),a("li",[v._v("简述排序算法——快排，partion 函数的原理，堆排（不稳定），归并排序，基数排序")]),v._v(" "),a("li",[v._v('把 "www.zhidao.baidu.com" 这样的字符串改成 "com/baidu/zhidao/www"。——老题目了，剑指 offer 的，两次逆序排列即可。')])]),v._v(" "),a("p",[v._v("了解以下排序的时间、空间复杂度，是否稳定，实现原理")]),v._v(" "),a("ul",[a("li",[v._v("归并排序、拓展：求数组中的逆序对个数")]),v._v(" "),a("li",[v._v("快速排序 重点：partion 函数的实现")]),v._v(" "),a("li",[v._v("堆排序")]),v._v(" "),a("li",[v._v("数组元素值域已知时，考虑 基数排序 和 桶排序")])]),v._v(" "),a("h2",{attrs:{id:"二叉树"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[v._v("#")]),v._v(" 二叉树")]),v._v(" "),a("ul",[a("li",[v._v("二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？")]),v._v(" "),a("li",[v._v("写了一个查找某路径是否存在于某二叉树内题")]),v._v(" "),a("li",[v._v("一棵完全二叉树，再给你一个新节点，你把这个节点插到合适的位置，让它还是一棵完全二叉树")])]),v._v(" "),a("h2",{attrs:{id:"查找匹配"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#查找匹配"}},[v._v("#")]),v._v(" 查找匹配")]),v._v(" "),a("ul",[a("li",[v._v("{}"),a("a",{attrs:{href:""}}),v._v("判断括号匹配性")]),v._v(" "),a("li",[v._v("只有一种括号，计算最少加多少个括号，使其满足匹配")])]),v._v(" "),a("h2",{attrs:{id:"随机"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#随机"}},[v._v("#")]),v._v(" 随机")]),v._v(" "),a("ul",[a("li",[v._v("请用 rand1To5 实现等概率随机产生 1~7 的随机函数 rand1To7")])]),v._v(" "),a("h2",{attrs:{id:"其他"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#其他"}},[v._v("#")]),v._v(" 其他")]),v._v(" "),a("ul",[a("li",[v._v("大数相乘")])]),v._v(" "),a("h2",{attrs:{id:"实际应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#实际应用"}},[v._v("#")]),v._v(" 实际应用")]),v._v(" "),a("ul",[a("li",[v._v("一个 TableView，假设它没有复用，可能有一万个（或者更多）个 Cell，给你一段屏幕的纵坐标区间[X, Y]，请你找出在区间内的所有 cell 并按顺序返回")]),v._v(" "),a("li",[v._v("给 1G 内存，1T 数据，数据是一个大文件，文件每一行都是一个 URL，去重（跟面试官掰扯了半天没搞定。其实当时前几天我还跟我男票嘱咐了几次让他复习这个（他当时准备跳槽），但我以为我客户端不会问这个，结果...）")]),v._v(" "),a("li",[v._v("不用临时变量怎么实现 swap(a, b)——用加法或者异或都可以")]),v._v(" "),a("li",[v._v("亿级日志中，查找登陆次数最多的十个用户——（不确定对不对，我的思路是）先用哈希表保存登陆次数和 ID，然后用红黑树保存最大的十个数。剑指 offer 第 30 题")])])])}),[],!1,null,null,null);_.default=l.exports}}]);