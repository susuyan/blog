# 内存管理

1. 严格的内存管理，能够是我们的应用程在性能上有很大的提高
2. 如果忽略内存管理，可能导致内存泄漏应用占用内存过高，导致程序崩溃

## 概念

- 内存管理的方式有哪些？
  1. ARC
  2. MRC
  3. 内存池
  4. 垃圾回收机制
- 苹果官方基础内存管理规则:
  1. 你拥有你创建的任何对象
  2. 你可以使用 retain 获取一个对象的拥有权
  3. 当你不再需要它，你必须放弃你拥有的对象的拥有权
  4. 你一定不能释放不是你拥有的对象的拥有权

## 自动释放池

- 自动释放池底层怎么实现？

(以栈的方式实现的)(系统自动创建，系统自动释放)栈里面的(先进后出)
内存里面有栈，栈里面有自动释放池。
自动释放池以栈的形式实现：当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送 autorelease 消息时,它被添加到当前线程的处于栈顶的自动释放池中，当自动释放池被回收时，它们从栈中被删除，并且会给池子里面所有的对象都会做一次 release 操作。

- 什么是自动释放池？
  用来存储多个对象类型的指针变量
- 自动释放池对池内对象的作用，自动释放池的作用？ 1.被存入到自动释放池内的对象，当自动释放池被销毁时，会对池内的对象全部做一次 release 操作。 2.将对象与自动释放池建立关系，池子内调用 autorelease 方法，在自动释放池销毁时销毁对象，延迟 release 销毁时间。
- 对象如何放入到自动释放池中？
  当你确定要将对象放入到池中的时候，只需要调用对象的 autorelease 对象方法就可以把对象放入到自动释放池中
- 多次调用对象的 autorelease 方法会导致什么问题？
  多次将地址存到自动释放池中，导致野指针异常

- 自动释放池，什么时候创建？ 1.程序刚启动的时候，也会创建一个自动释放池 2.产生事件以后，运行循环开始处理事件，就会创建自动释放池

- 自动释放池，什么时候销毁？ 1.程序运行结束之前销毁 2.事件处理结束以后，会销毁自动释放池 3.还有在池子满的时候，也会销毁
- 自动释放池使用注意事项：
  不要把大量循环操作放在释放池下，因为这会导致大量循环内的对象没有被回收，这种情况下应该手动写 release 代码。尽量避免对大内存对象使用 autorelease，否则会延迟大内存的回收。
- autorelease 的对象是在什么时候被 release 的？
  autorelease 实际上只是把对 release 的调用延迟了，对于每一个 Autorelease，系统只是把该 Object 放入当前的 Autorelease 中，当该 pool 被释放时，该 pool 中的所有 Object 会被调用 release。对于每一个 Runloop，系统会隐式创建一个 Autoreleasepool，这样所有的 releasepool 会构成一个像 CallStack 一样的一个栈式结构，在每一个 Runloop 结束时，当前栈顶的 Autoreleasepool 会被销毁，这样这个 pool 里的每个 Object 会被 Release。

- 如果我们没有在应用程序中创建任何自动释放池，那么是否已经提供了任何自动释放池？
  系统会默认不定时地创建和销毁自动释放池

- 什么时候在应用程序中创建自动释放池？
  当不需要精确地控制对象的释放时间时，可以手动创建自动释放池

## 内存分析

- 静态分析
- 动态分析

### 什么情况下会发生内存泄漏和内存溢出？

内存泄漏：堆里不再使用的对象没有被销毁，依然占据着内存。
内存溢出：内存泄漏到一定的阈值时，程序在申请空间内存时，并没有内存空间使用，这时就会溢出。

## 内存分区

- 代码区：存放函数二进制代码
- 数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量
- 堆区：通过 malloc 等函数或 new 等操作符动态申请得到，需程序员手动申请和释放
- 栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数

堆和栈的区别？

- 管理方式：
  堆释放工作由程序员控制，容易产生 memory leak；
  栈是由编译器自动管理，无需我们手工控制。
- 申请大小：
  堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
  栈：在 Windows 下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 Windows 下，栈的大小是 2M（也有的说是 1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
- 碎片问题：
  堆：频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。
  栈：则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出
- 分配方式：
  堆都是动态分配的，没有静态分配的堆。
  栈有 2 种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由 alloc 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
- 分配效率：
  栈：是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。
  堆：则是 C/C++函数库提供的，它的机制是很复杂的。
  每个 App 有个内存空间，假定是 4G，分为堆和栈两大部分。一般来说每个进程有一个堆（这个进程的所有线程共用这个堆），进程中的线程有自己栈。
  通过 alloc、new 或 malloc 获得的内存在堆中分配，堆中的内存需要写相应的代码释放。如果进程结束了在堆中分配的内存会自动释放。
  局部变量、函数参数是在栈空间中分配，如果函数返回这个函数中的局部变量、参数所占的内存系统自动释放（回收）。
  程序在编译期对变量和函数分配内存都在栈上进行，且程序运行过程中函数调用时参数的传递也在栈上进行。
