# 关于 Block

- **Block 的循环引用、如何解决、原理？**

使用 weak，\_\_block,关键字来修饰对象。

- **Block 和 delegate 的比较**
  - 都可做回调来使用。
  - block，会有循环引用风险，所以要进行代码管理
  - delegate 没有延长某个对象生命周期，代码更加清晰，易于管理
  - block 适合做集约型调用
  - delegate 适合做离散型调用

总之，要灵活的使用 block 和 delegate。

- **block 本质是什么？**
  简单理解，匿名函数，然后将匿名函数当做对象来看

- block 和函数指针的理解？
  相似点：函数指针和 block 都可以实现回调的操作，声明上也相似

不同点：
_ 函数指针只能指向预先定义好的函数代码块，函数地址是在编译链接时就已经确定好的。
_ block 的本质即使一个对象，可以接受消息
_ 函数指针只能访问全局变量，而 block 不光能访问全局变量，还拥有当前栈内存和堆内存变量
_ 从内存的角度看，函数指针只不过是指向代码区的一段可执行代码，而 block 实际上是程序运行过程中在栈内存动态创建的对象，可以向其发送 copy 消息将 block 对象拷贝到堆内存，以延长其生命周期。

- **block 为什么会有循环引用？**

在 block 块中捕获变量，导致变量不能释放，所以造成循环引用

- **一个 int 变量被\_\_block 修饰与否的区别？**

没有修饰，被 block 捕获，是值拷贝。使用修饰时，会生成一个结构体，复制 int 的引用地址，达到修改数据。

- 为什么在 block 外部使用**weak 修饰的同时需要在内部使用**strong 修饰？

- Block 的变量截获的
- \_\_block 的实现原理
- Block 的变量截获机制（局部变量：基础类型，对象类型，静态变量；全局变量：静态，非静态 blahblah）
- 说说你对 block 的理解。—— 三种 block，栈上的自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。
